
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com\jkk111\indigo\proxy\proxy-router.go (60.8%)</option>
				
				<option value="file1">github.com\jkk111\indigo\proxy\proxy-rules.go (83.3%)</option>
				
				<option value="file2">github.com\jkk111\indigo\proxy\round-tripper_windows.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package proxy

import (
  "net"
  "net/http"
  "net/http/httputil"
  "fmt"
  "time"
  "strings"
  URL "net/url"
  "bytes"
  "github.com/jkk111/indigo/assets"
  "reflect"
)

var transport * BetterRoundTripper = newBetterRoundTripper(nil)
var ProxyInstance * ReverseProxy

type BetterRoundTripper struct {
  transport http.RoundTripper
}

func newBetterRoundTripper(tr http.RoundTripper) * BetterRoundTripper <span class="cov8" title="1">{
  if tr == nil </span><span class="cov8" title="1">{
    tr = http.DefaultTransport
  }</span>

  <span class="cov8" title="1">return &amp;BetterRoundTripper{ tr }</span>
}

type BufferedCloser struct {
  *bytes.Buffer
}

func (this * BufferedCloser) Close() (err error) <span class="cov0" title="0">{
  return
}</span>

func NewBufferedCloser(buf []byte) * BufferedCloser <span class="cov0" title="0">{
  b := bytes.NewBuffer(buf)
  return &amp;BufferedCloser{b}
}</span>

func conn_failed() * http.Response <span class="cov0" title="0">{
  r := &amp;http.Response{}
  r.StatusCode = 502
  r.Body = NewBufferedCloser(assets.MustAsset("resources/ServiceUnavailable.html"))
  return r
}</span>

func conn_refused() * http.Response <span class="cov0" title="0">{
  r := &amp;http.Response{}
  r.StatusCode = 502
  r.Body = NewBufferedCloser([]byte("Connection Failed, Server Refused Connection"))
  return r
}</span>

func handle_proxy_error(req * http.Request, err error) * http.Response <span class="cov0" title="0">{
  fmt.Println(err)
  switch t := err.(type) </span>{
    case *net.OpError:<span class="cov0" title="0">
      if t.Op == "dial" </span><span class="cov0" title="0">{
        return conn_failed()
      }</span> else<span class="cov0" title="0"> if t.Op == "read" </span><span class="cov0" title="0">{
        return conn_refused()
      }</span>

    default:<span class="cov0" title="0">
      fmt.Println("Unknown Error:", reflect.TypeOf(err))
      return conn_failed()</span>
  }

  <span class="cov0" title="0">return nil</span>
}

// We store some essential paths in the headers to handle passing,
// Easy in v 1-3 because node allows dynamic mutation of the request
// Work-around for golang
func (this * BetterRoundTripper) SocketRoundTrip(req * http.Request) (res * http.Response, err error) <span class="cov8" title="1">{
  req.URL.Scheme = "http"

  tp := &amp;http.Transport{
    Proxy: http.ProxyFromEnvironment,
    DialContext: this.socketRoundTrip,
    MaxIdleConns:          100,
    IdleConnTimeout:       90 * time.Second,
    TLSHandshakeTimeout:   10 * time.Second,
    ExpectContinueTimeout: 1 * time.Second,
  }

  return tp.RoundTrip(req)
}</span>

func (this * BetterRoundTripper) RoundTrip(req * http.Request) (*http.Response, error) <span class="cov8" title="1">{
  var res * http.Response
  var err error

  dest := req.Header.Get("X-Dest")

  if dest == "" </span><span class="cov0" title="0">{
    fmt.Println("Invalid Round Trip")
    return conn_refused(), nil
  }</span>

  // Special Case, Windows specific named pipe.
  <span class="cov8" title="1">if dest == "local" </span><span class="cov8" title="1">{
    res, err = this.SocketRoundTrip(req)
  }</span> else<span class="cov0" title="0"> if dest == "unix" </span>{<span class="cov0" title="0"> // Unix Socket
    // res, err := UnixRoundTrip(req)
  }</span> else<span class="cov0" title="0"> {
    res, err = this.transport.RoundTrip(req) 
  }</span>

  <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
    return handle_proxy_error(req, err), nil
  }</span> 

  <span class="cov8" title="1">return res, err</span>
}

type ProxyRuleSet struct {
  Rules map[string]*HttpProxyRules
}

func NewProxyRuleSet() * ProxyRuleSet <span class="cov8" title="1">{
  rules := make(map[string]*HttpProxyRules)
  return &amp;ProxyRuleSet{ Rules: rules }
}</span>

func (this * ProxyRuleSet) domain(domain string) <span class="cov8" title="1">{
  if this.Rules[domain] == nil </span><span class="cov8" title="1">{
    this.Rules[domain] = NewHttpProxyRules()
  }</span>
}

func (this * ProxyRuleSet) Match(domain string, url string) (route * RuleMatch) <span class="cov8" title="1">{
  this.domain(domain)
  this.domain("*")
  wildcard_match := this.Rules["*"].Match(url)
  match := this.Rules[domain].Match(url)

  if wildcard_match == nil </span><span class="cov8" title="1">{
    return match
  }</span> else<span class="cov8" title="1"> if match == nil </span><span class="cov8" title="1">{
    return wildcard_match
  }</span>

  <span class="cov0" title="0">if wildcard_match.Strength == -1 &amp;&amp;  match.Strength == -1 </span><span class="cov0" title="0">{
    return nil
  }</span> 

  <span class="cov0" title="0">if wildcard_match.Strength &gt; match.Strength </span><span class="cov0" title="0">{
    return wildcard_match
  }</span> else<span class="cov0" title="0"> {
    return match
  }</span>
}

func (this * ProxyRuleSet) Add(domain string, url string, route string, local bool) <span class="cov8" title="1">{
  this.domain(domain)
  this.Rules[domain].Add(url, route, local)
}</span>

type ReverseProxy struct {
  proxy_rules * ProxyRuleSet
}

func NewReverseProxy() * ReverseProxy <span class="cov8" title="1">{
  rp := &amp;ReverseProxy {
    proxy_rules: NewProxyRuleSet(),
  }

  ProxyInstance = rp

  return rp
}</span>

func (this * ReverseProxy) AddRoute(domain string, url string, route string, local bool) <span class="cov8" title="1">{
  this.proxy_rules.Add(domain, url, route, local)
}</span>

func (this * ReverseProxy) Router(w http.ResponseWriter, r * http.Request) <span class="cov8" title="1">{
  path := r.URL.Path
  host := r.URL.Hostname()

  if host == "" </span><span class="cov8" title="1">{
    host = r.Header.Get("Host")
  }</span>

  <span class="cov8" title="1">if host == "" </span><span class="cov8" title="1">{
    host = "localhost"
  }</span>

  <span class="cov8" title="1">if host == "" </span><span class="cov0" title="0">{
    host = r.Host
  }</span>

  <span class="cov8" title="1">match := this.proxy_rules.Match(host, path)

  if match != nil </span><span class="cov8" title="1">{
    fixed_path := strings.Replace(path, match.Prefix, "", -1)

    if fixed_path == "" </span><span class="cov8" title="1">{
      fixed_path = "/"
    }</span> else<span class="cov0" title="0"> if fixed_path[0] != '/' </span><span class="cov0" title="0">{
      fixed_path = "/" + fixed_path
    }</span>

    <span class="cov8" title="1">m := match.Match

    var url * URL.URL

    if match.Local </span><span class="cov8" title="1">{
      url = &amp;URL.URL{
        Scheme: "http",
        Path: fixed_path,
        Host: m,
      }
    }</span> else<span class="cov0" title="0"> {
      url, err := url.Parse(m)

      if err != nil </span><span class="cov0" title="0">{
        w.Write([]byte("Broke"))
        return
      }</span>

      <span class="cov0" title="0">url.Path = fixed_path</span>      
    }

    <span class="cov8" title="1">proxy := httputil.NewSingleHostReverseProxy(url)
    proxy.Transport = transport
    r.URL.Path = fixed_path

    r.Header.Set("X-Original-Host", host)
    r.Header.Set("X-Original-Path", path)
    r.Header.Set("X-Proxied-Path", fixed_path)
    r.Header.Set("X-Proxied-URL", m)
    var dest string

    if match.Local </span><span class="cov8" title="1">{
      dest = "local"
    }</span> else<span class="cov0" title="0"> {
      dest = "remote"
    }</span>

    <span class="cov8" title="1">r.Header.Set("X-Dest", dest)

    proxy.ServeHTTP(w, r)</span>
  
  } else<span class="cov8" title="1"> {
    w.Write([]byte("Invalid Route"))
  }</span>
}

func SetProxyTransport(tr http.RoundTripper) <span class="cov0" title="0">{
  transport.transport = tr
}</span>

func Instance() * ReverseProxy <span class="cov8" title="1">{
  return ProxyInstance
}</pre>
		
		<pre class="file" id="file1" style="display: none">package proxy

import "regexp"
import "strings"
import "fmt"

type ProxyRule struct {
  Route string // Socket // Host
  Local bool
}

type HttpProxyRules struct {
  Rules map[string]*ProxyRule
  Default string
}

func NewHttpProxyRules() * HttpProxyRules <span class="cov8" title="1">{
  rules := make(map[string]*ProxyRule)
  return &amp;HttpProxyRules{ Rules: rules }
}</span>

func (this * HttpProxyRules) Add(path string, route string, local bool) <span class="cov8" title="1">{
  if this.Rules[path] == nil </span><span class="cov8" title="1">{
    this.Rules[path] = &amp;ProxyRule{route, local}
  }</span> else<span class="cov0" title="0"> {
    fmt.Println(path, route)
    panic("Overwriting Existing Rule")</span>
  }
}

type RuleMatch struct {
  Match string
  Prefix string
  Strength int
  Local bool
}

func (this * HttpProxyRules) Match(url string) * RuleMatch <span class="cov8" title="1">{
  if url[0] != '/' </span><span class="cov0" title="0">{
    url = "/" + url
  }</span>

  <span class="cov8" title="1">path := url
  var bestMatchStrength int
  var bestMatch * ProxyRule
  var bestPrefix string
  matched := false

  for prefix, rule := range this.Rules </span><span class="cov8" title="1">{
    var trailing_slash bool
    var pathPrefixRe * regexp.Regexp

    if prefix[len(prefix) - 1] == '/' </span><span class="cov0" title="0">{
      pathPrefixRe = regexp.MustCompile(strings.Replace(prefix, "/", "\\/", -1))
      trailing_slash = true
    }</span> else<span class="cov8" title="1"> {
      pathPrefixRe = regexp.MustCompile("(" + strings.Replace(prefix, "/", "\\/", -1) + `)(?:\W|$)`)
      trailing_slash = false
    }</span>

    <span class="cov8" title="1">testPrefixMatchIndex := pathPrefixRe.FindStringIndex(path)
    testPrefixMatch := pathPrefixRe.FindStringSubmatch(path)

    if testPrefixMatchIndex != nil &amp;&amp; testPrefixMatchIndex[0] == 0 </span><span class="cov8" title="1">{
      var url_prefix string
      if trailing_slash </span><span class="cov0" title="0">{
        url_prefix = testPrefixMatch[0]
      }</span> else<span class="cov8" title="1"> {
        url_prefix = testPrefixMatch[1]
      }</span>

      <span class="cov8" title="1">matchStrength := computeMatchStrength(path, testPrefixMatch[0])

      if matchStrength &gt; bestMatchStrength </span><span class="cov8" title="1">{
        if url_prefix != "" </span><span class="cov8" title="1">{
          bestPrefix = url_prefix
        }</span>

        <span class="cov8" title="1">bestMatch = rule
        bestMatchStrength = matchStrength
        matched = true</span>
      }
    }
  }

  <span class="cov8" title="1">if !matched </span><span class="cov8" title="1">{
    bestMatchStrength = -1
    return nil
  }</span>

  <span class="cov8" title="1">return &amp;RuleMatch { bestMatch.Route, bestPrefix, bestMatchStrength, bestMatch.Local }</span>
}

func computeMatchStrength(url string, match string) int <span class="cov8" title="1">{
  i := 0

  l := len(url)
  lm := len(match)

  if lm &lt; l </span><span class="cov0" title="0">{
    l = lm
  }</span>

  <span class="cov8" title="1">for ;i &lt; l; i++ </span><span class="cov8" title="1">{
    if url[i] != match[i] </span><span class="cov0" title="0">{
      return i
    }</span>
  }

  <span class="cov8" title="1">return i</span>
}</pre>
		
		<pre class="file" id="file2" style="display: none">package proxy

import (
  "net"
  "context"
  "github.com/jkk111/indigo/sockets"
)

func (this * BetterRoundTripper) socketRoundTrip(ctx context.Context, network string, addr string) (c net.Conn, err error) <span class="cov8" title="1">{
  return sockets.Dial(addr)
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
